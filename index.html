<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Physics Sandbox</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useRef, useEffect, useState } = React;
        
        const PhysicsSandbox = () => {
          const canvasRef = useRef(null);
          const [isPaused, setIsPaused] = useState(false);
          const [gravity, setGravity] = useState(0.5);
          const [restitution, setRestitution] = useState(0.7);
          const [tool, setTool] = useState('circle');
          const objectsRef = useRef([]);
          const wallsRef = useRef([]);
          const animationRef = useRef(null);
          const mouseRef = useRef({ down: false, x: 0, y: 0, drawStart: null, draggedObj: null });

          useEffect(() => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#1a0a00');
            bgGradient.addColorStop(0.5, '#2d1500');
            bgGradient.addColorStop(1, '#1f0d00');

            const updatePhysics = () => {
              if (isPaused) return;

              objectsRef.current = objectsRef.current.map(obj => {
                if (obj.dragging) return obj;

                obj.vy += gravity;
                obj.x += obj.vx;
                obj.y += obj.vy;

                if (obj.type === 'circle') {
                  if (obj.x - obj.radius < 0) {
                    obj.x = obj.radius;
                    obj.vx *= -restitution;
                  }
                  if (obj.x + obj.radius > canvas.width) {
                    obj.x = canvas.width - obj.radius;
                    obj.vx *= -restitution;
                  }
                  if (obj.y + obj.radius > canvas.height) {
                    obj.y = canvas.height - obj.radius;
                    obj.vy *= -restitution;
                    obj.vx *= 0.95;
                  }
                  if (obj.y - obj.radius < 0) {
                    obj.y = obj.radius;
                    obj.vy *= -restitution;
                  }
                } else {
                  if (obj.x < 0) {
                    obj.x = 0;
                    obj.vx *= -restitution;
                  }
                  if (obj.x + obj.width > canvas.width) {
                    obj.x = canvas.width - obj.width;
                    obj.vx *= -restitution;
                  }
                  if (obj.y + obj.height > canvas.height) {
                    obj.y = canvas.height - obj.height;
                    obj.vy *= -restitution;
                    obj.vx *= 0.95;
                  }
                  if (obj.y < 0) {
                    obj.y = 0;
                    obj.vy *= -restitution;
                  }
                }

                wallsRef.current.forEach(wall => {
                  if (obj.type === 'circle') {
                    const closestX = Math.max(wall.x, Math.min(obj.x, wall.x + wall.width));
                    const closestY = Math.max(wall.y, Math.min(obj.y, wall.y + wall.height));
                    const dx = obj.x - closestX;
                    const dy = obj.y - closestY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < obj.radius) {
                      const angle = Math.atan2(dy, dx);
                      obj.x = closestX + Math.cos(angle) * obj.radius;
                      obj.y = closestY + Math.sin(angle) * obj.radius;
                      
                      const nx = dx / dist;
                      const ny = dy / dist;
                      const dot = obj.vx * nx + obj.vy * ny;
                      obj.vx = (obj.vx - 2 * dot * nx) * restitution;
                      obj.vy = (obj.vy - 2 * dot * ny) * restitution;
                    }
                  } else {
                    if (obj.x < wall.x + wall.width && obj.x + obj.width > wall.x &&
                        obj.y < wall.y + wall.height && obj.y + obj.height > wall.y) {
                      const overlapX = Math.min(obj.x + obj.width - wall.x, wall.x + wall.width - obj.x);
                      const overlapY = Math.min(obj.y + obj.height - wall.y, wall.y + wall.height - obj.y);
                      
                      if (overlapX < overlapY) {
                        if (obj.x < wall.x) obj.x = wall.x - obj.width;
                        else obj.x = wall.x + wall.width;
                        obj.vx *= -restitution;
                      } else {
                        if (obj.y < wall.y) obj.y = wall.y - obj.height;
                        else obj.y = wall.y + wall.height;
                        obj.vy *= -restitution;
                      }
                    }
                  }
                });

                return obj;
              });

              for (let i = 0; i < objectsRef.current.length; i++) {
                for (let j = i + 1; j < objectsRef.current.length; j++) {
                  const a = objectsRef.current[i];
                  const b = objectsRef.current[j];
                  
                  if (a.type === 'circle' && b.type === 'circle') {
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = a.radius + b.radius;

                    if (dist < minDist) {
                      const angle = Math.atan2(dy, dx);
                      const overlap = minDist - dist;
                      
                      a.x -= Math.cos(angle) * overlap * 0.5;
                      a.y -= Math.sin(angle) * overlap * 0.5;
                      b.x += Math.cos(angle) * overlap * 0.5;
                      b.y += Math.sin(angle) * overlap * 0.5;

                      const nx = dx / dist;
                      const ny = dy / dist;
                      const dvx = b.vx - a.vx;
                      const dvy = b.vy - a.vy;
                      const dot = dvx * nx + dvy * ny;

                      if (dot < 0) {
                        a.vx += dot * nx * restitution;
                        a.vy += dot * ny * restitution;
                        b.vx -= dot * nx * restitution;
                        b.vy -= dot * ny * restitution;
                      }
                    }
                  }
                }
              }
            };

            const draw = () => {
              ctx.fillStyle = bgGradient;
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              const glowGradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height, 200,
                canvas.width / 2, canvas.height, 600
              );
              glowGradient.addColorStop(0, 'rgba(255, 100, 0, 0.3)');
              glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
              ctx.fillStyle = glowGradient;
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              wallsRef.current.forEach(wall => {
                const wallGradient = ctx.createLinearGradient(wall.x, wall.y, wall.x + wall.width, wall.y + wall.height);
                wallGradient.addColorStop(0, '#2a1510');
                wallGradient.addColorStop(0.5, '#1a0a05');
                wallGradient.addColorStop(1, '#3a1a10');
                ctx.fillStyle = wallGradient;
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                
                ctx.strokeStyle = 'rgba(255, 80, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
              });

              if (mouseRef.current.down && tool === 'wall' && mouseRef.current.drawStart) {
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                  mouseRef.current.drawStart.x,
                  mouseRef.current.drawStart.y,
                  mouseRef.current.x - mouseRef.current.drawStart.x,
                  mouseRef.current.y - mouseRef.current.drawStart.y
                );
              }

              objectsRef.current.forEach(obj => {
                if (obj.type === 'circle') {
                  const glowGrad = ctx.createRadialGradient(obj.x, obj.y, obj.radius * 0.5, obj.x, obj.y, obj.radius * 1.5);
                  glowGrad.addColorStop(0, obj.color);
                  glowGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                  ctx.fillStyle = glowGrad;
                  ctx.beginPath();
                  ctx.arc(obj.x, obj.y, obj.radius * 1.5, 0, Math.PI * 2);
                  ctx.fill();
                  
                  const objGradient = ctx.createRadialGradient(obj.x - obj.radius * 0.3, obj.y - obj.radius * 0.3, 0, obj.x, obj.y, obj.radius);
                  objGradient.addColorStop(0, obj.color2);
                  objGradient.addColorStop(1, obj.color);
                  ctx.fillStyle = objGradient;
                  ctx.beginPath();
                  ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                  ctx.fill();
                } else {
                  ctx.shadowBlur = 20;
                  ctx.shadowColor = obj.color;
                  
                  const objGradient = ctx.createLinearGradient(obj.x, obj.y, obj.x + obj.width, obj.y + obj.height);
                  objGradient.addColorStop(0, obj.color2);
                  objGradient.addColorStop(1, obj.color);
                  ctx.fillStyle = objGradient;
                  ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                  
                  ctx.shadowBlur = 0;
                }
              });

              updatePhysics();
              animationRef.current = requestAnimationFrame(draw);
            };

            draw();

            return () => {
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
          }, [isPaused, gravity, restitution, tool]);

          const handleMouseDown = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            mouseRef.current = { down: true, x, y };

            const clickedObj = objectsRef.current.find(obj => {
              if (obj.type === 'circle') {
                const dx = obj.x - x;
                const dy = obj.y - y;
                return Math.sqrt(dx * dx + dy * dy) < obj.radius;
              } else {
                return x > obj.x && x < obj.x + obj.width && y > obj.y && y < obj.y + obj.height;
              }
            });

            if (clickedObj) {
              mouseRef.current.draggedObj = clickedObj;
              clickedObj.dragging = true;
              clickedObj.vx = 0;
              clickedObj.vy = 0;
            } else if (tool === 'wall') {
              mouseRef.current.drawStart = { x, y };
            } else {
              const hue = 10 + Math.random() * 30;
              const newObj = tool === 'circle' 
                ? { 
                    type: 'circle', 
                    x, 
                    y, 
                    radius: 20 + Math.random() * 20, 
                    vx: (Math.random() - 0.5) * 5, 
                    vy: 0,
                    color: `hsl(${hue}, 100%, ${40 + Math.random() * 20}%)`,
                    color2: `hsl(${hue}, 100%, ${60 + Math.random() * 20}%)`
                  }
                : { 
                    type: 'box', 
                    x: x - 20, 
                    y: y - 20, 
                    width: 30 + Math.random() * 30, 
                    height: 30 + Math.random() * 30,
                    vx: (Math.random() - 0.5) * 5, 
                    vy: 0,
                    color: `hsl(${hue}, 100%, ${40 + Math.random() * 20}%)`,
                    color2: `hsl(${hue}, 100%, ${60 + Math.random() * 20}%)`
                  };
              objectsRef.current.push(newObj);
            }
          };

          const handleMouseMove = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (mouseRef.current.down) {
              if (mouseRef.current.draggedObj) {
                const obj = mouseRef.current.draggedObj;
                obj.vx = (x - obj.x) * 0.2;
                obj.vy = (y - obj.y) * 0.2;
                if (obj.type === 'circle') {
                  obj.x = x;
                  obj.y = y;
                } else {
                  obj.x = x - obj.width / 2;
                  obj.y = y - obj.height / 2;
                }
              }
              mouseRef.current.x = x;
              mouseRef.current.y = y;
            }
          };

          const handleMouseUp = (e) => {
            if (tool === 'wall' && mouseRef.current.drawStart) {
              const rect = canvasRef.current.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              const startX = Math.min(mouseRef.current.drawStart.x, x);
              const startY = Math.min(mouseRef.current.drawStart.y, y);
              const width = Math.abs(x - mouseRef.current.drawStart.x);
              const height = Math.abs(y - mouseRef.current.drawStart.y);
              
              if (width > 5 && height > 5) {
                wallsRef.current.push({ x: startX, y: startY, width, height });
              }
            }
            
            if (mouseRef.current.draggedObj) {
              mouseRef.current.draggedObj.dragging = false;
            }
            
            mouseRef.current = { down: false, x: 0, y: 0, drawStart: null, draggedObj: null };
          };

          const Circle = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <circle cx="12" cy="12" r="10"/>
            </svg>
          );

          const Square = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
            </svg>
          );

          const Pencil = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
            </svg>
          );

          const Play = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <polygon points="6 3 20 12 6 21 6 3"/>
            </svg>
          );

          const Pause = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
            </svg>
          );

          const Trash2 = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
          );

          return (
            <div className="w-full h-screen bg-gradient-to-b from-gray-900 via-orange-950 to-red-950 flex flex-col">
              <div className="bg-gradient-to-r from-gray-900 via-orange-900 to-gray-900 p-4 flex gap-4 items-center flex-wrap border-b-2 border-orange-600">
                <button
                  onClick={() => setIsPaused(!isPaused)}
                  className="px-4 py-2 bg-gradient-to-r from-orange-600 to-red-600 hover:from-orange-700 hover:to-red-700 rounded flex items-center gap-2 shadow-lg shadow-orange-900/50 text-white"
                >
                  {isPaused ? <Play size={20} /> : <Pause size={20} />}
                  {isPaused ? 'Resume' : 'Pause'}
                </button>
                
                <button
                  onClick={() => { objectsRef.current = []; wallsRef.current = []; }}
                  className="px-4 py-2 bg-gradient-to-r from-red-700 to-red-900 hover:from-red-800 hover:to-red-950 rounded flex items-center gap-2 shadow-lg shadow-red-900/50 text-white"
                >
                  <Trash2 size={20} />
                  Clear
                </button>

                <div className="flex gap-2">
                  <button
                    onClick={() => setTool('circle')}
                    className={`px-4 py-2 rounded flex items-center gap-2 shadow-lg text-white ${tool === 'circle' ? 'bg-gradient-to-r from-yellow-600 to-orange-600 shadow-orange-700/50' : 'bg-gray-800 hover:bg-gray-700'}`}
                  >
                    <Circle size={20} />
                    Circle
                  </button>
                  <button
                    onClick={() => setTool('box')}
                    className={`px-4 py-2 rounded flex items-center gap-2 shadow-lg text-white ${tool === 'box' ? 'bg-gradient-to-r from-yellow-600 to-orange-600 shadow-orange-700/50' : 'bg-gray-800 hover:bg-gray-700'}`}
                  >
                    <Square size={20} />
                    Box
                  </button>
                  <button
                    onClick={() => setTool('wall')}
                    className={`px-4 py-2 rounded flex items-center gap-2 shadow-lg text-white ${tool === 'wall' ? 'bg-gradient-to-r from-yellow-600 to-orange-600 shadow-orange-700/50' : 'bg-gray-800 hover:bg-gray-700'}`}
                  >
                    <Pencil size={20} />
                    Wall
                  </button>
                </div>

                <div className="flex items-center gap-2">
                  <label className="text-white text-sm">Gravity:</label>
                  <input
                    type="range"
                    min="0"
                    max="2"
                    step="0.1"
                    value={gravity}
                    onChange={(e) => setGravity(parseFloat(e.target.value))}
                    className="w-32"
                  />
                  <span className="text-white text-sm w-8">{gravity.toFixed(1)}</span>
                </div>

                <div className="flex items-center gap-2">
                  <label className="text-white text-sm">Bounce:</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.05"
                    value={restitution}
                    onChange={(e) => setRestitution(parseFloat(e.target.value))}
                    className="w-32"
                  />
                  <span className="text-white text-sm w-8">{restitution.toFixed(2)}</span>
                </div>
              </div>

              <canvas
                ref={canvasRef}
                width={1200}
                height={700}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                className="flex-1 cursor-crosshair"
              />
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PhysicsSandbox />);
    </script>
</body>
</html>
